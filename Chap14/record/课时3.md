在对称加密部分，关注点主要在DES算法和AES算法上。这一节课的内容是DES算法的详解。课程设计如下：

1. DES算法的介绍

   DES算法的产生，1970年代，国家密码局

   DES的基本特征，输入、输出、加密的情况（分组）、密钥的长度、常用的模式

2. 手算DES

   先带大家过一遍DES的WIKI或者KCTF，大致了解一下整体的架构。

   需要说明的是，DES是最后一个可以比较轻松的、无需前置数学知识就可以分析和手算的主流现代加密算法。

   为了减轻理解上的负担，结合Python实现代码以及C实现代码一起讲。同时，先不考虑Padding以及工作模式，即我们的输入为64比特长，不进行padding（按照pkcs 7 padding的话，得增加一个分组）又因为只有一个分组，也不考虑工作模式，继而也不用考虑IV。

   

   明文：0123456789ABCDEF

   密钥：133457799BBCDFF1

   第零步是处理明文

   明文的二进制形式是64比特

   使用cyberchef得到如下

   00000001 00100011 01000101 01100111 10001001 10101011 11001101 11101111

   根据IP表（Initial Permutation）对明文进行重新排列

   ![5](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\5.png)

   看表可能有点抽象和不好理解，看下面这张图就一下子豁然开朗了。

   我们一起来走一遍，DES加密中，充满了此类置换。

   ![8](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\8.png)

   1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0

   初始置换就做好了，接下来做下一步

   密钥的编排——生成16轮次的子密钥

   00010011 00110100 01010111 01111001 10011011 10111100 11011111 11110001

   ![4](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\4.png)

   根据PC-1（*Permuted Choice 1*  置换选择1表）进行重排

   1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1

   在密钥的这步置换中，密钥每个字节的最后一位都没有采用，所以我们说，DES的密钥有效位只有56位。

   接下来将这56比特长的密钥分成左右两部分，并命名为C0，D0。

   **C0** = 1111000 0110011 0010101 0101111
   **D0** = 0101010 1011001 1001111 0001111

   

   接下来循环左移规定的位数，得到C1，D1 到 C16，D16的十六个子密钥。

   将CnDn合并，根据PC-2（*Permuted Choice* 2  置换选择2表）进行重排，56比特长的CnDn 只留下48比特。

   重拍后CnDn便成了子密钥，因此命名CnDn为Kn，此例Kn如下：

   **K1** = 000110 110000 001011 101111 111111 000111 000001 110010

   **K2** = 011110 011010 111011 011001 110110 111100 100111 100101
   **K3** = 010101 011111 110010 001010 010000 101100 111110 011001
   **K4** = 011100 101010 110111 010110 110110 110011 010100 011101
   **K5** = 011111 001110 110000 000111 111010 110101 001110 101000
   **K6** = 011000 111010 010100 111110 010100 000111 101100 101111
   **K7** = 111011 001000 010010 110111 111101 100001 100010 111100
   **K8** = 111101 111000 101000 111010 110000 010011 101111 111011
   **K9** = 111000 001101 101111 101011 111011 011110 011110 000001
   **K10** = 101100 011111 001101 000111 101110 100100 011001 001111
   **K11** = 001000 010101 111111 010011 110111 101101 001110 000110
   **K12** = 011101 010111 000111 110101 100101 000110 011111 101001
   **K13** = 100101 111100 010111 010001 111110 101011 101001 000001
   **K14** = 010111 110100 001110 110111 111100 101110 011100 111010
   **K15** = 101111 111001 000110 001101 001111 010011 111100 001010
   **K16** = 110010 110011 110110 001011 000011 100001 011111 110101

   

   子密钥的生成到此结束，后续DES的十六轮运算中，第n轮就是用Kn。

   Python中结果也可以验证。

   

   算法主要分成两部分：明文的运算和密钥的编排

   接下来就是明文的十六轮运算

   

   首先将明文分成左右两半，像上面的密钥一样。

   L0 和 R0

   L0：11001100 00000000 11001100 11111111 

   R0：11110000 10101010 11110000 10101010

   接下来经过16轮迭代，结果就出来了

   **Ln** = **Rn-1**
   **Rn** = **Ln-1** + **f**(**Rn-1**,**Kn**)

   不知道大家会不会想到MD5，MD5中每一轮，只改变ABCD中一个，其余三个进行平移赋值，Ln和Rn也有这味儿。需要注意的是，MD5中凡是“+”运算，指的是简单加法，如果超过0xFFFFFFFF大小则取低32位，而DES中“+”指的是按位异或运算。

   L1 = R0 = 11110000 10101010 11110000 10101010

   R1 = Ln-1 xor f(Rn-1,Kn)

   接下来的关注点就在f函数上了。在MD5中也有一个F函数，但它只是运算的一部分，而DES中的F函数，代表了16轮运算中一轮的全部运算。

   以n = 1为例，f函数传入了R0与K1，即第一个子密钥。

   R0 = 11110000 10101010 11110000 10101010

   **K1** = 000110 110000 001011 101111 111111 000111 000001 110010

   可以发现，R0是32比特长，K1是48比特长，长度上就不相同，没法按比特进行运算。

   所以第一步，是对R0进行扩展，同样是使用一个表，这个表叫Expand表，即扩展表。在扩展表中，16个比特位被使用了两次。因此R0长度从32比特被扩展成了48比特。

   ![10](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\10.png)

   R0 = 1111 0000 1010 1010 1111 0000 1010 1010

   E(R0) = 011110 100001 010101 010101 011110 100001 010101 010101



​		接下来是**Kn** + **E**(**Rn-1**)，对于第一轮就是E(R0) 和 K1 异或，这一步在AES中同样存在，专业说法叫密钥混合。

​		E(R0) = 011110 100001 010101 010101 011110 100001 010101 010101

​		**K1**   =   000110 110000 001011 101111 111111 000111 000001 110010



​		**K1**+**E**(**R0**) = 011000 010001 011110 111010 100001 100110 010100 100111

​		

​		F函数远未结束，想一下我们已经做了哪些步，结合看雪的图

​		https://bbs.pediy.com/thread-90593.htm

​		我们先将传入的R0扩展成48比特，再将它与本轮的密钥异或。

​		最后我们得到了48比特的结果，从上面数据的表示上可以看出，我把它当成了8个6比特的数据，这是因为我		们后续就要这么使用它。在AES中同样有这个操作，大家可以触类旁通。

​		也就是，即将来到DES加密的核心，S盒。对于没有接触过此类转换的同学来说，可能觉得有些奇怪。

​		首先，我们将上面一步的结果当成8块6比特长的输入

​		**K1**+**E**(**R0**) = **B1B2B3B4B5B6B7B8** 

​		那么

​		B1 = 011000

​		B2 = 010001

​		B3 = 011110 

​		B4 = 111010 

​		B5 = 100001

​		B6 = 100110 

​		B7 = 010100 

​		B8 = 100111

​		接下来，我们把B1-B8的值当成地址或者说索引，去S1-S8盒中找对应的值。

​		规则如下：

​		以B1为例，值为011000，一个6比特长的二进制数，我们将它分成两部分

​		i = 00 即 0

​		j = 1100 即 12

​	![11](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\11.png)		

​		

​		（0，12）= 5

​		因为B是六比特长，b1b2b3b4b5b6

​		b1b6的范围是0-3

​		b2b3b4b5的范围是0-15

​		即与表实现了完全的对应，不会有B的“索引”超出表的大小。

​		B1在S1中找，B2在S2中找，以此类推

​		最后8个6比特的值在S盒作用下变成8个4比特的值

​		S(**K1**+**E**(**R0**)) = 0101 1100 1000 0010 1011 0101 1001 0111

​		我们可能只会觉得挺好玩的，但实际上，S盒是DES安全性的核心，没有S盒，DES脆弱不堪。

​		接下来进行P盒置换，就是简单的置换，没什么好说的。

![12](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\12.png)

​		P(S(**K1**+**E**(**R0**))) = 0010 0011 0100 1010 1010 1001 1011 1011

​		F 函数大功告成

​		即F = P(S(**K1**+**E**(**R0**)))

​		F的结果与L0异或

​		L1 = R0 = 11110000 10101010 11110000 10101010

​		R1 = Ln-1 xor f(Rn-1,Kn) = 11101111 01001010 01100101 01000100

​		

​		第一轮彻底结束，接下来进行16轮完全一致的操作，

		L1:11110000 10101010 11110000 10101010
R1:11101111 01001010 01100101 01000100
L2:11101111 01001010 01100101 01000100
R2:11001100 00000001 01110111 00001001
L3:11001100 00000001 01110111 00001001
R3:10100010 01011100 00001011 11110100
L4:10100010 01011100 00001011 11110100
R4:01110111 00100010 00000000 01000101
L5:01110111 00100010 00000000 01000101
R5:10001010 01001111 10100110 00110111
L6:10001010 01001111 10100110 00110111
R6:11101001 01100111 11001101 01101001
L7:11101001 01100111 11001101 01101001
R7:00000110 01001010 10111010 00010000
L8:00000110 01001010 10111010 00010000
R8:11010101 01101001 01001011 10010000
L9:11010101 01101001 01001011 10010000
R9:00100100 01111100 11000110 01111010
L10:00100100 01111100 11000110 01111010
R10:10110111 11010101 11010111 10110010
L11:10110111 11010101 11010111 10110010
R11:11000101 01111000 00111100 01111000
L12:11000101 01111000 00111100 01111000
R12:01110101 10111101 00011000 01011000
L13:01110101 10111101 00011000 01011000
R13:00011000 11000011 00010101 01011010
L14:00011000 11000011 00010101 01011010
R14:11000010 10001100 10010110 00001101
L15:11000010 10001100 10010110 00001101
R15:01000011 01000010 00110010 00110100
L16:01000011 01000010 00110010 00110100
R16:00001010 01001100 11011001 10010101

得到L16和R16后，左右调一下顺序

结果为R16L16

**R16L16** = 00001010 01001100 11011001 10010101 01000011 01000010 00110010 00110100

接下来可以还差最后一步，末置换，末置换当然也要用表，表叫FP表（即Final Permutation）

看一下下图可以很清晰的发现就是初始置换的逆运算

![7](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\7.png)

它是遥遥呼应初始置换的一步，因此，如果一个64比特的明文首先经过初始置换，不做任何处理再进行一次末尾置换，值等于它自身。

有始有终，这一步我们手算吧

![13](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\13.png)

00001010 01001100 11011001 10010101 01000011 01000010 00110010 00110100

结果

10000101 11101000 00010011 01010100 00001111 00001010 10110100 00000101

85e813540f0ab405

cyberchef

85e813540f0ab405 fdf2e174492922f8



接下来引出两个问题

这两个问题不是专属于DES的问题，而是所有分组密码，或者绝大多数密码算法都要考虑的内容

1.如果明文长度不够一个分组怎么办

当明文长度不够分组大小时，我们需要指定某个标准进行填充，就像MD5一样，使得加密内容的长度到达该分组密码的一个分组大小。当解密时，按照此标准，再将填充部分删掉即可。（这也是cyberchef在3des第二轮出错的原因）



现在最常用的标准是PCKS7PADDING，也是cyberchef采用的填充方式。

我们采用三个方式来了解和验证这种填充方式的存在和使用方法

1是传入内容为空，发现仍然有一个分组的密文输出

2是传入一个分组大小的内容，发现密文输出为两个分组长度，这一点就像MD5的填充一样，如果你选择进行填充，那么不论如何都必须要填充，比如MD5，最小填充1位，因为计算机以字节为处理单位，所以最小填充一个字节，在MD5的填充规则里就是1000 0000，十六进制表示为0x80，所以我们会在MD5实现代码中看到直接在明文编码后附上0x80，因为不论如何，总是要填充的。而PCKS7PADDING也同理，最少填充一个字节，填充01

最多填充1个分组，内容为08 08 08 08 08 08 08 08 

以此类推，如果需要填充两个字节，那就是02 02

三个字节 03 03 03

四个字节 04 04 04 04 

五个字节 05 05 05 05 05 

六个字节 06 06 06 06 06 06 

七个字节 07 07 07 07 07 07 07



2.如果明文长度超过一个分组长度，那如何处理呢？

每个分组单独处理？还是彼此之间有联系呢？

这就是工作模式

每个分组单独加密，就好像很多个一分组的DES的这种处理方式，叫ECB工作模式。

这种模式有很多好处，我们可以直接for 循环，将很长的输入分成对应个数的分组，每个分组得到结果后拼接在一起就行，而且这也意味着可以并行计算。

如果ECB模式是可行的、安全的，那么我们一定选择它，因为最简单和高效。那也就不会出现别的工作模式了，可惜的是它并不安全。

![14](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\14.png)

相同的明文会被加密成相同的密文，这是很危险的。

举两个经典的例子。

1.使用ECB加密数据，可能出现这样一种情况。

密文为三个分组的密文

分组1：付款人

分组2：收款人

分组3：转账金额

只需要将密文块1和密文块2进行对调，竟然内容就截然相反了。

ECB在某些情况下，使得攻击者可以在完全不破解密文的情况下，操纵明文。

第二个例子是ECB模式对图像的加密，更为生动

在ECB模式中，如果两个分组的的内容相同，那么输出也一定相同

这就造成了下面这种尴尬的局面

原图

![15](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\15.jpg)



ECB后

![16](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\16.jpg)

我们期待的结果

![17](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\17.jpg)

因为ECB模式是不安全的，所以我们需要安全的方案。

最常用的是CBC模式，其实也很简单，来看一下。

![18](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\18.png)

其实想法也很朴素，每个明文分组在加密前多一个步骤，和上一个分组的密文块进行异或运算。

因为第一个明文块没有所谓的“上一个分组的密文块“，所以需要人给一个64比特，或者说8字节的输入，我们叫它初始化向量，IV。

在cyberchef中验证一下

明文：123456789ABCDEF0

密钥：133457799BBCDFF1

使用CBC模式

IV：0123456789ABCDEF



计算结果

0ecb68bac16aece0 7cbadcfa7a974bcc



接下来想一下，怎么单独的算出它

按照我们上面的说法

0ecb68bac16aece0的明文应该就是123456789ABCDEF0和0123456789ABCDEF异或的结果

使用cyberchef计算123456789ABCDEF0 ^ 0123456789ABCDEF

得到结果1317131f1317131f

单独计算其DES加密结果，注意这儿要用ECB模式

0ecb68bac16aece0 fdf2e174492922f8

可以发现，第一块加密结果正是我们所预期的。

接下来看一下第二块，第二块即0808080808080808

按照CBC的规则

计算0ecb68bac16aece0 ^ 0808080808080808 = 06c360b2c962e4e8

单独计算ECB下的06c360b2c962e4e8

结果为7cbadcfa7a974bcc  fdf2e174492922f8

第二块结果也完全正确。

我们对CBC模式的理解已经到位了。



接下来理解一下CFB模式

明文：123456789ABCDEF0

密钥：133457799BBCDFF1

使用CFB模式

IV：0123456789ABCDEF

结果

97dc452c95b66af5



IV即0123456789ABCDEF的des加密结果85e813540f0ab405

85e813540f0ab405 与 123456789ABCDEF0 的异或结果是97dc452c95b66af5



接下来理解一下OFB模式

明文：123456789ABCDEF0

密钥：133457799BBCDFF1

使用OFB模式

IV：0123456789ABCDEF

结果

97dc452c95b66af5

即一个分组的OFB与CFB是一样一样的



测试一下两个分组

接下来理解一下OFB模式

明文：123456789ABCDEF0 123456789ABCDEF0

密钥：133457799BBCDFF1

使用OFB模式

IV：0123456789ABCDEF

结果：97dc452c95b66af5  759a2c51fb637db5

我们直接观察第二个分组

759a2c51fb637db5

如何计算出来呢

它是明文和加密两次的IV的异或结果

明文：123456789ABCDEF0

加密第一次：

85e813540f0ab405

加密第二次

67ae7a2961dfa345f

67ae7a2961dfa345f ^ 123456789ABCDEF0 = 759a2c51fb637db5



这就是OFB模式



有些同学可能会想到MD5

虽然是哈希函数，但哈希其实也都是分组，但不叫分组密码。

而哈希算法呢，每个块的计算输出其实也是密文，但它没有保存下来，它作为下一轮的ABCD继续运算。只有最后一个分组计算出的ABCD，才作为哈希结果。

所以其实哈希算法中的魔数，专业叫法叫初始化链接变量，就是分组密码中的IV的意思。



~~如果将每一分组运算出的~~ABCD保留下来，那它就是一个分组密码，但大家不要去尝试，这是最脆弱的分组密码。反过来，分组密码都可以用来设计哈希算法，这是行业内的一个常见思路。优点是分组密码的研究很充分，有非常多可以移植和魔改的分组密码，安全性也很好。坏处是分组密码运算比较慢。

所以目前主流仍然是MD5、SHA家族，别的离传播开来世界通用还有很远的路要走。



除此之外，OFB/CFB均可转化成流密码，这会增加识别难度。

明文：a1

密钥：0123456789abcdef

使用CFB模式

IV：0123456789ABCDEF

Result：f7



第一步，IV加密 56cc09e7cfdc4cef

第二步：56~~cc09e7cfdc4cef~~ ^ a1 = f7

OFB/CFB都可以作为流加密，即不需要填充，，因为xor按位即可，多出来的不去管就行。













1. DES算法的细节

   DES算法虽然不算复杂，但可以说是划时代的加密算法。

   第一个现代且通用的加密算法

   第一个广为人知的分组加密算法

   第一个广为人知的对称加密算法

   它有非常多的细节可以去谈，但是一口气将全部细节讲述清楚，既超出了我的能力范围，也不符合学习和认知的规律，所以咱们一步一步来，努力把内容讲清楚。

   如果你对DES算法已经有一些了解，听课过程中发现某个地方和你认知不太一样，或者不太准确，先别急，不妨先跟着走下去，等全篇都结束，看看疑问有没有打消。

   如果你对DES毫无了解，在听课的过程中，多暂停多思考，努力跟着复现，一定会受益匪浅！

   同时，我们推荐了一些拓展性的资料，如果你希望更深的学习DES算法，或者作为开发者，希望魔改出自己的，安全且较难以被破解的DES版本，可以看看这些资料。

   

   * S盒的设计

     我们至今仍然不知道S盒哪来的，但我们知道了S盒的设计理念。

     S盒是DES算法的核心，但是S盒的设计一直是个谜。为什么S盒长这样？NSA不愿意说。因此，DES陷入了长达15年的“陷门危机”，陷门就是后门的意思，即人们担心S盒的设计暗藏玄机，使得设计方NSA有办法快速的逆向破解DES，这种言论发酵和持续到90年代，一直到差分攻击的发现，真相才浮出水面。

     90年代，两位以色列的密码学家发现了一种强大的密码分析方法，并将之命名为差分攻击。这是一种空前强大的密码学分析方法，可以很好的攻击当时的各种主流密码算法。但是好巧不巧，在DES上效果不佳。

     这时候IBM的研究人员见时机已到，于是公开了S盒的设计理念。原来，在70年代时，IBM公司就已经知道并掌握了差分攻击。为了让DES这个未来的美国加密标准（DATA Encrypt Standard）更安全，所以精心设计了S盒，让DES可以抵御差分攻击，但是，NSA在更早就掌握了这一技术，NSA认为这个技术可以破译同期的大多数密码算法，为了使美国在密码分析领域保持世界领先地位，所以NSA禁止IBM公开和透露差分攻击的任何消息，那么自然，S盒的设计理念也就没法公开。

     因为信息差以及教材落后，至今许多国内的密码学课堂中，仍然以为DES藏有后门。

     

   * 密钥的设计

     IBM本来提交的DES设计中，密钥有效位112比特，美国国家安全局（NSA）将它砍了一半，有效位长56比特，几乎可以确认，这是为了降低自身破解DES所需的成本。这确实是坏心眼。

     

   * 初始置换的意义

     初始置换和末置换缺少密码学上的意义，只是单纯对明文进行了重新排列，不对安全性有任何影响，简直毫无作用，以至于后来的一些软件实现中取消了这两步，这可以认为是一种简单的、不会影响安全性的魔改方案。

     它的设计原因，有研究者认为是为了打乱连续的ASCII码，或者抵御某种仿真攻击。

     但真实原因在一次下午茶中被揭秘了出来

     一位教授和IBM的研究者一起喝茶，这位研究人员恰好是DES设计团队中的一员：

     DES的方案产生后，必须要制作一台对应的DES加密机用作展示。因为上世纪的加解密实现主要依赖于硬件。

     IBM的工程师在制造完加密机后，发现加密机的布线有点糟糕，简直杂乱不堪。评估后认为，这样乱糟糟的，可能得重新制作加密机。

     但是那个时代，制造加密机的成本很高，即使IBM都心疼。于是天才的密码学家们想了个办法，既然改答案比较难，我就改题目。

     他们直接修改了尚未发布的DES标准，增加了并不影响算法强度和安全性的初始置换和对应的末置换，布线上舒服多了。

     这是stackoverflow上的一个说法，感兴趣的可以自己去查查，我就不考证了。

   * DES的安全性问题

     毫无疑问，56位的有效密钥长度，如今已经不再安全了，甚至90年代，就可以通过几百万美元的机器，只花费几个月就能实施破解。

     现在依然推荐的方案是3DES，它增强了安全性，在银行等系统上仍较多使用。

     

2. 3 DES 的实现

   3 DES的设计乍看有点奇怪

   ![1](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\1.png)

   先加密后解密再加密，这就是标准的3DES，也叫EDE方案，即Encrypt-Decrypt-Encrypt方案。解密时就是解密-加密-解密。

   

   需要传入24个字节或者说三个密钥。

   * 前8字节是第一步DES加密的密钥

   * 中间8字节是第二步DES解密的密钥

   * 最后8字节是第三步DES加密的密钥

   为什么要做这种奇怪的设计呢？以至于有些论文中都搞错了，以为3 DES就是3次不同密钥的DES加密。

   事实上，这种设计有两种考量

   1.DES的第二轮是解密，但因为第二轮的密钥并不是真不是正确的密钥，所以会进一步扰乱数据。

   2.DES是由IBM公司设计的，3DES的标准自然也是IBM提出的，IBM是这么想的，DES广泛用于银行等系统，这些系统的更新比较慢，因此兼容性问题是很重要的议题。加密-解密-加密的3DES设计，在三个密钥都相同时，就变成了加密-对加密结果解密-再加密，即等同于普通的DES，这就实现了向下兼容。

   在Cyberchef中测试3DES是不是我们想的那样

   测试一：

   明文（hex）：0123456789abcdef

   密钥K1：0123456789abcdef

   密钥K2：123456789abcdef0

   密钥K3：23456789abcdef01

   密钥K1K2K3：0123456789abcdef123456789abcdef023456789abcdef01

   结果

   f631d2f3d1b6ef4be253849a96ba3dde

   

   分开进行

   第一次

   56cc09e7cfdc4cef086f9a1d74c94d4e

   解密的时候，cyberchef出了问题

   改用[DES Encryption – Easily encrypt or decrypt strings or files (online-domain-tools.com)](http://des.online-domain-tools.com/)

   日噢，我发现cyberchef的解密哪里有问题了，cyberchef默认采用pkcs#7 的填充，也默认认为你既然让我来解密，那它就是有原文的。

   那么在算出结果之后，因为默认使用了pkcs #7填充，它就去末尾找0808080808080808了，并打算把它去掉，前面的部分就是明文，因为我们的第二步DES解密就是错误的，所以它没没找到，所以就陷入了错误！！！

   

   第二次

   efeeae57d3ef1c698fef1a4975193013

   第三次

   f631d2f3d1b6ef4be253849a96ba3dde9d2747b43409d819

   为什么会这样呢？结果的前32位一致，后16位和3DES不匹配。

   

   

   3DES

   测试二：

   [Triple DES Encrypt - CyberChef (gchq.github.io)](https://gchq.github.io/CyberChef/#recipe=Triple_DES_Encrypt({'option':'Hex','string':'1234567890abcdef1234567890abcdef1234567890abcdef'},{'option':'Hex','string':''},'ECB','Hex','Hex')&input=MTIzNDU2)

   ![2](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\2.png)

   [DES Encrypt - CyberChef (gchq.github.io)](https://gchq.github.io/CyberChef/#recipe=DES_Encrypt({'option':'Hex','string':'1234567890abcdef'},{'option':'Hex','string':''},'ECB','Hex','Hex')&input=MTIzNDU2)

   ![3](C:\Users\pr0214\Desktop\DTA\SO基础课4月\对称加密算法\资料\record\pics\3.png)

   

   可以发现，三个同样密钥的3DES，加密结果与普通DES相同。

   

   接下来看一下3DES的其他实现方案

   * DES-EEE3模式，该模式需要传入3个不同密钥，进行三次DES加密。
   * DES-EEE2模式，该模式需要传入2个不同密钥，三次DES加密，第一次和第三次使用相同密钥K1，第二个密钥K2 不等于 K1。
   * DES-EDE2模式，该模式需要传入2个不同密钥，进行加密-解密-加密操作，第一次和第三次使用相同密钥K1，第二个密钥K2 不等于 K1，否则就变成简单DES加密。

   这三个方案都是安全可靠但非标准的3DES方案，并不推荐使用单个密钥进行3次DES加密，安全性相较于上述四种方案，有所下降。

   可以发现，依赖于密钥的变化和组合，即使在不修改DES本身代码的情况下，3DES也有很多花样可以玩。

   

3. DES 的工程实现

   工程实现中，各类加密算法都会采用查表法，以空间换时间，加快运算速度。

   但AES/DES等加密算法，有时还会更进一步，将其中多个表合并，以更大的空间换取更快的速度。

   AES

   > AES中列混淆部分设计有限域乘法操作，在运行中需要消耗较多的时间。现在的计算平台都拥有丰富的软件资源(RAM、Flash等)，因此AES的软件实现一般都会采用**查表**的方式，将字节替代、行移位、列混淆合在一起查表，大概消耗8-10K字节的存储空间，但效率非常之高。

   

   DES

   > The S-boxes are usually implemented as lookup tables in software. We refer to the input to an S-box lookup table as the index, and we refer to the possible outputs of the S-box as the table entries. To eliminate processing associated with the P-box Permutation, software implementations of DES often combine the P-box Permutation with the S-box lookup tables to form SP-box lookup tables. Each S-box outputs a 4-bit value, but the SP-boxes output a 32-bit or larger value in which the 4-bit S-box result is already permuted per the P-box Permutation. Hence, no explicit run-time processing is needed to complete the P-box Permutation: The permu tation is built into the eight SP-box lookup tables. If the SP-box outputs are 32 bits in size, the 28 output bits that do not represent bits of the original 4-bit S-box output are set to zeroes. The results of the eight SP-box outputs can be combined by performing seven bitwise logical XOR or bitwise logical OR operations following the eight SP-box table lookups.

   

   实际例子

   https://github.com/weidai11/cryptopp/blob/2d8e4680855691657cb8029ae5cb05c67c6dc654/dessp.cpp

   

   

   padding模式的问题

   我想验证除了padding一整个分组的情况

   KEY = 133457799BBCDFF1

   

   明文：0107070707070707 01

   结果：68375127b13da4f7 68375127b13da4f7

   

   可以发现，结果是两个重复且一致的密文块

   因为按照对应填充规则，DES分组长度为8字节，最后一个分组缺少7个字节长度，所以在十六进制下，填充7个07。

   

   

   还缺少两块知识

   1是填充模式

   2是分组密码工作模式

   

   关于填充模式，DES/AES主要用*PKCS5Padding* / PKCS7Padding，或者NOPADDING

   RSA有自己的填充模式。

   

   RSA的每轮运算主要包含四部分

   密钥混合，循环左移，字节替换（S盒），列混淆

   除了列混淆以外的操作，我们都在DES或者哈希算法中见识过了，列混淆是AES的精髓，里面包含了充分的数学美感。

   

   

   

   

   